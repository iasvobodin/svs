#ifdef GL_ES
precision mediump float;
#endif
#define PI_2 6.283185307179586
float exponentialOut(float t) {
 return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);
}
// those are the mandatory attributes that the lib sets
attribute vec3 aVertexPosition;
attribute vec2 aTextureCoord;
// those are mandatory uniforms that the lib sets and that contain our model view and projection matrix
uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;
uniform float opacity;
uniform float progress;
uniform vec3 offset;
uniform float time;
// our texture matrix that will handle image cover
uniform mat4 uTextureMatrix0;
// pass your vertex and texture coords to the fragment shader
varying float vAlpha;
varying vec2 vUv;
varying vec3 vVertexPosition;
varying vec2 vTextureCoord;
void main() {
// vec3 vertexPosition = aVertexPosition;
vUv = aTextureCoord;
vec3 posSway = aVertexPosition; 
vec3 wave = offset;
wave.y += sin(time * 0.2 + aTextureCoord.x * 2.0 * PI_2 + aTextureCoord.y * 4.0 * PI_2) * 15.0;
posSway += wave;
vec2 d = sin(vUv * vec2(1.0, 2.0) * PI_2) * 0.25 + 0.25;
float s = smoothstep(0., 1., progress - d.x - d.y);
vec3 pos = mix(aVertexPosition, posSway, s); 
gl_Position = uPMatrix * uMVMatrix * vec4(pos.x/sin(time *.002), pos.yz, 1.0);
// set the varyings
// here we use our texture matrix to calculate the accurate texture coords
vTextureCoord = (uTextureMatrix0 * vec4(vUv, 0.0, 1.0)).xy;
// vVertexPosition = vertexPosition;
vAlpha = exponentialOut(1.0 - s) * opacity;
}